"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These will be generated by the genabi script
// For now, we'll use placeholder types
type PollABI = any[];
type PollFactoryABI = any[];

export type PollMetadata = {
  owner: string;
  name: string;
  details: string;
  endTime: bigint;
  startTime: bigint;
  isOpen: boolean;
};

export type PollInfo = {
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
  abi: PollABI;
  factoryAddress?: `0x${string}`;
  factoryABI: PollFactoryABI;
};

export type EncryptedVote = {
  optionIndex: number;
  handle: string;
  proof: string;
};

export type AggregatedResult = {
  totalVotes: bigint;
  optionSums: bigint[];
  optionCounts: bigint[];
  averages: number[];
};

export const usePoll = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
  pollAddress?: `0x${string}`;
  factoryAddress?: `0x${string}`;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
    pollAddress,
    factoryAddress,
  } = parameters;

  const [metadata, setMetadata] = useState<PollMetadata | undefined>(
    undefined
  );
  const [voteCount, setVoteCount] = useState<bigint>(0n);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isRequestingAggregation, setIsRequestingAggregation] =
    useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [aggregatedResult, setAggregatedResult] =
    useState<AggregatedResult | undefined>(undefined);
  const [message, setMessage] = useState<string>("");
  const [encryptionProgress, setEncryptionProgress] = useState<{
    current: number;
    total: number;
  }>({ current: 0, total: 0 });

  const pollRef = useRef<PollInfo | undefined>(undefined);
  const isSubmittingRef = useRef<boolean>(false);
  const isRequestingAggregationRef = useRef<boolean>(false);
  const isDecryptingRef = useRef<boolean>(false);

  // Load poll metadata
  const loadMetadata = useCallback(async () => {
    if (!pollAddress || !ethersReadonlyProvider || !chainId) {
      return;
    }

    try {
      const pollABI = [
        "function getInfo() external view returns (address owner, string memory name, string memory details, uint256 endTime, uint256 startTime, bool isOpen)",
        "function getVoteCount() external view returns (uint256)",
      ];

      const contract = new ethers.Contract(
        pollAddress,
        pollABI,
        ethersReadonlyProvider
      );

      const [infoResult, voteCountResult] = await Promise.all([
        contract.getInfo(),
        contract.getVoteCount(),
      ]);

      setMetadata({
        owner: infoResult.owner,
        name: infoResult.name,
        details: infoResult.details,
        endTime: infoResult.endTime,
        startTime: infoResult.startTime,
        isOpen: infoResult.isOpen,
      });

      setVoteCount(voteCountResult);
    } catch (e: any) {
      console.error("Failed to load poll metadata:", e);
      setMessage("Failed to load poll metadata: " + (e.message || e));
    }
  }, [pollAddress, ethersReadonlyProvider, chainId]);

  // Load metadata on mount and when dependencies change
  useEffect(() => {
    loadMetadata();
  }, [loadMetadata]);

  // Submit encrypted votes
  const submitVotes = useCallback(
    async (votes: number[]) => {
      if (
        isSubmittingRef.current ||
        !pollAddress ||
        !instance ||
        !ethersSigner ||
        !chainId
      ) {
        return;
      }

      if (votes.length === 0) {
        setMessage("Please provide at least one vote");
        return;
      }

      const thisPollAddress = pollAddress;
      const thisEthersSigner = ethersSigner;
      const thisChainId = chainId;

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage("Starting encryption...");
      setEncryptionProgress({ current: 0, total: votes.length });

      const run = async () => {
        const isStale = () =>
          thisPollAddress !== pollAddress ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Encrypt each vote
          const encryptedVotes: EncryptedVote[] = [];
          const handles: string[] = [];
          const proofs: string[] = [];

          for (let i = 0; i < votes.length; i++) {
            if (isStale()) {
              setMessage("Submission cancelled");
              return;
            }

            setMessage(`Encrypting vote ${i + 1}/${votes.length}...`);
            setEncryptionProgress({ current: i + 1, total: votes.length });

            // Validate vote range (1-5 for Likert scale)
            if (votes[i] < 1 || votes[i] > 5) {
              throw new Error(`Vote ${i + 1} must be between 1 and 5`);
            }

            // Create encrypted input for this vote
            const input = instance.createEncryptedInput(
              thisPollAddress,
              thisEthersSigner.address
            );

            // Add vote as euint8 (values 1-5)
            input.add8(BigInt(votes[i]));

            // Encrypt (CPU-intensive)
            await new Promise((resolve) => setTimeout(resolve, 100));
            const enc = await input.encrypt();

            const handleHex = ethers.hexlify(enc.handles[0]);
            handles.push(handleHex);
            proofs.push(enc.inputProof as unknown as string);

            encryptedVotes.push({
              optionIndex: i,
              handle: handleHex,
              proof: enc.inputProof as unknown as string,
            });
          }

          if (isStale()) {
            setMessage("Submission cancelled");
            return;
          }

          setMessage("Submitting to contract...");

          // Create contract instance with proper ABI
          // Note: externalEuint8 is encoded as bytes32 in the ABI
          const pollABI = [
            "function submitEncryptedVote(bytes32[] calldata _votes, bytes[] calldata _inputProofs) external",
            "event VoteSubmitted(uint256 indexed voteId, address indexed voter, uint256 timestamp)",
          ];

          const contract = new ethers.Contract(
            thisPollAddress,
            pollABI,
            thisEthersSigner
          );

          setMessage("Sending transaction to blockchain...");

          // Call submitEncryptedVote on the contract
          // handles are already in bytes32 format from FHEVM encryption
          const tx = await contract.submitEncryptedVote(
            handles,
            proofs
          );

          setMessage("Waiting for transaction confirmation...");

          // Wait for transaction to be mined
          const receipt = await tx.wait();

          if (!receipt) {
            throw new Error("Transaction failed - no receipt");
          }

          if (isStale()) {
            setMessage("Submission cancelled");
            return;
          }

          setMessage("Votes submitted successfully! Transaction hash: " + receipt.hash);
          await loadMetadata();
        } catch (error: any) {
          console.error("Submit error:", error);
          setMessage(`Submission failed: ${error.message || error}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
          setEncryptionProgress({ current: 0, total: 0 });
        }
      };

      run();
    },
    [
      pollAddress,
      instance,
      ethersSigner,
      chainId,
      sameChain,
      sameSigner,
      loadMetadata,
    ]
  );

  // Request aggregation
  const requestAggregation = useCallback(async () => {
    if (
      isRequestingAggregationRef.current ||
      !pollAddress ||
      !ethersSigner ||
      !chainId
    ) {
      return;
    }

    const thisPollAddress = pollAddress;
    const thisEthersSigner = ethersSigner;
    const thisChainId = chainId;

    isRequestingAggregationRef.current = true;
    setIsRequestingAggregation(true);
    setMessage("Requesting aggregation...");

    const run = async () => {
      const isStale = () =>
        thisPollAddress !== pollAddress ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const pollABI = [
          "function requestAggregation() external returns (uint256)",
          "event AggregationRequested(uint256 indexed requestId, uint256 timestamp)",
        ];

        const contract = new ethers.Contract(
          thisPollAddress,
          pollABI,
          thisEthersSigner
        );

        setMessage("Sending aggregation request to contract...");

        // Call requestAggregation()
        const tx = await contract.requestAggregation();

        setMessage("Waiting for transaction confirmation...");
        const receipt = await tx.wait();

        if (!receipt) {
          throw new Error("Transaction failed - no receipt");
        }

        if (isStale()) {
          setMessage("Request cancelled");
          return;
        }

        // Extract request ID from event
        const event = receipt.logs.find((log: any) => {
          try {
            const parsed = contract.interface.parseLog(log);
            return parsed && parsed.name === "AggregationRequested";
          } catch {
            return false;
          }
        });

        let requestId = "N/A";
        if (event) {
          const parsed = contract.interface.parseLog(event);
          // Safely access nested fields
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const args: any = parsed?.args;
          requestId = args?.requestId?.toString?.() ?? "N/A";
        }

        setMessage(
          `Aggregation requested successfully! Request ID: ${requestId}. Coprocessors will process the data.`
        );
      } catch (error: any) {
        setMessage(`Aggregation request failed: ${error.message || error}`);
      } finally {
        isRequestingAggregationRef.current = false;
        setIsRequestingAggregation(false);
      }
    };

    run();
  }, [pollAddress, ethersSigner, chainId, sameChain, sameSigner]);

  // Decrypt aggregated results
  const decryptAggregatedResults = useCallback(async () => {
    if (isDecryptingRef.current || !pollAddress || !instance || !ethersSigner) {
      return;
    }

    const thisPollAddress = pollAddress;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Starting decryption...");

    const run = async () => {
      const isStale = () =>
        thisPollAddress !== pollAddress ||
        !sameSigner.current(thisEthersSigner);

      try {
        // Check if signature exists in cache
        setMessage("Checking for decryption signature...");
        const userAddress = (await ethersSigner.getAddress()) as `0x${string}`;
        
        let cachedSig: FhevmDecryptionSignature | null = null;
        try {
          cachedSig = await FhevmDecryptionSignature.loadFromGenericStringStorage(
            fhevmDecryptionSignatureStorage,
            instance,
            [thisPollAddress],
            userAddress
          );
        } catch (e) {
          console.warn("Failed to load cached signature:", e);
        }

        let sig: FhevmDecryptionSignature | null = null;

        if (cachedSig && cachedSig.isValid()) {
          setMessage("Using cached decryption signature...");
          sig = cachedSig;
        } else {
          // Need to create new signature - this will prompt user to sign
          setMessage("Creating new decryption signature. Please sign the message in your wallet...");
          try {
            sig = await FhevmDecryptionSignature.loadOrSign(
              instance,
              [thisPollAddress],
              ethersSigner,
              fhevmDecryptionSignatureStorage
            );

            if (!sig) {
              setMessage("Unable to build decryption signature. Please try again.");
              return;
            }

            setMessage("Decryption signature created successfully!");
          } catch (signError: any) {
            console.error("Signature error:", signError);
            if (signError.message?.includes("user rejected") || signError.code === 4001) {
              setMessage("Signature rejected. Please try again and approve the signature request.");
            } else {
              setMessage(`Signature failed: ${signError.message || signError}. Please check your wallet connection.`);
            }
            return;
          }
        }

        if (isStale()) {
          setMessage("Decryption cancelled");
          return;
        }

        setMessage("Fetching aggregated data from contract...");

        // Get aggregated data from contract
        const pollABI = [
          "function getAggregatedData() external view returns (bytes32 total, bytes32[] memory sums, bytes32[] memory counts)",
          "function optionCount() external view returns (uint8)",
        ];

        const contract = new ethers.Contract(
          thisPollAddress,
          pollABI,
          ethersReadonlyProvider
        );

        // Call getAggregatedData() - returns euint32 handles
        const [totalHandle, sumsHandles, countsHandles] =
          await contract.getAggregatedData();

        // Check if aggregation has been done
        if (!totalHandle || totalHandle === ethers.ZeroHash) {
          setMessage(
            "No aggregated results yet. Please request aggregation first."
          );
          return;
        }

        // Get option count
        const optionCount = Number(await contract.optionCount());

        if (sumsHandles.length !== optionCount || countsHandles.length !== optionCount) {
          setMessage("Aggregated data incomplete. Please request aggregation again.");
          return;
        }

        setMessage("Decrypting aggregated results...");

        // Batch decrypt all handles at once for efficiency
        const allHandles = [
          { handle: totalHandle, contractAddress: thisPollAddress },
          ...sumsHandles.map((h: `0x${string}`) => ({
            handle: h,
            contractAddress: thisPollAddress,
          })),
          ...countsHandles.map((h: `0x${string}`) => ({
            handle: h,
            contractAddress: thisPollAddress,
          })),
        ];

        setMessage(`Decrypting ${allHandles.length} encrypted values...`);

        const allDecrypted = await instance.userDecrypt(
          allHandles,
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        // Extract decrypted values
        const decryptedTotalValue = allDecrypted[totalHandle];
        const sums: bigint[] = [];
        const counts: bigint[] = [];

        for (let i = 0; i < sumsHandles.length; i++) {
          sums.push(BigInt(allDecrypted[sumsHandles[i]] || 0));
          counts.push(BigInt(allDecrypted[countsHandles[i]] || 0));
        }

        if (isStale()) {
          setMessage("Decryption cancelled");
          return;
        }

        // Calculate averages
        const averages = sums.map((sum, i) => {
          const count = counts[i];
          return count > 0n ? Number(sum) / Number(count) : 0;
        });

        setAggregatedResult({
          totalVotes: BigInt(decryptedTotalValue || 0),
          optionSums: sums,
          optionCounts: counts,
          averages,
        });

        setMessage("Decryption completed successfully!");
      } catch (error: any) {
        console.error("Decrypt error:", error);
        setMessage(`Decryption failed: ${error.message || error}`);
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    pollAddress,
    instance,
    ethersSigner,
    ethersReadonlyProvider,
    fhevmDecryptionSignatureStorage,
    sameSigner,
  ]);

  // Load metadata on mount and when dependencies change
  useEffect(() => {
    loadMetadata();
  }, [loadMetadata]);

  return {
    metadata,
    voteCount,
    isSubmitting,
    isRequestingAggregation,
    isDecrypting,
    aggregatedResult,
    message,
    encryptionProgress,
    submitVotes,
    requestAggregation,
    decryptAggregatedResults,
    loadMetadata,
  };
};




